%!TEX program = xelatex
\documentclass{article}
\usepackage{LaTeX-Submodule/template}

% Additional packages and macros
\usepackage{changepage} % Modify page width
\usepackage{multicol} % Use multiple columns
\usepackage{titlesec} % Modify section heading styles
\usepackage{textcomp, upquote}

%% A4 page
\geometry{
	a4paper,
	margin = 10mm
}

%% Hide horizontal rule
\renewcommand{\headrulewidth}{0pt}

% Modify spacing
\titlespacing*{\section}{0pt}{0\baselineskip}{0\baselineskip}
\titlespacing*{\subsection}{0pt}{0\baselineskip}{0\baselineskip}

\begin{document}
\lstset{language=Matlab, upquote=true}
\lstset{morekeywords={randi, false, imshow, drawpolygon, polyarea, drawline, ones, imread, VideoWriter, XData, YData, getFrame, writeVideo, deg2rad, soundsc, resample, audiowrite, }}
%
\section*{Random Numbers}
Let $M$, $N$ and $P$ define a $M\times N\times P$ array.
\begin{lstlisting}
rand([M, N, P], 'datatype')    % uniformly distributed random numbers between 0 & 1
randn([M, N, P], 'datatype')   % normally distributed random numbers
\end{lstlisting}
Random numbers between a \& b
\begin{lstlisting}
rand([M, N, P]) * (b - a) + a  % uniformly distributed random numbers
randn([M, N, P]) * (b - a) + a % normally distributed random numbers
randi([a, b], [M, N, P])       % uniformly distributed random integers
\end{lstlisting}
\section*{Data Types}
\begin{table}[H]
    \centering
    \begin{tabular}{c | c | c}
        \toprule
        \textbf{Name}       & \textbf{Description}              & \textbf{Range}                   \\
        \midrule
        \lstinline!logical! & boolean values                    & \lstinline!0 & 1!                \\
        \lstinline!uint8!   & unsigned 8-bit integers           & \lstinline!0 ... 2^8!            \\
        \lstinline!int8!    & unsigned 8-bit integers           & \lstinline!-2^8 ... 2^8!         \\
        \lstinline!single!  & single precision ``real'' numbers & \lstinline!-realmax ... realmax! \\
        \lstinline!double!  & double precision ``real'' numbers & \lstinline!-realmax ... realmax! \\
        \bottomrule
    \end{tabular}
\end{table}
(un)signed 16, 32, 64-bit storage for integer data is created by appending the size to ``(u)int''.
\section*{Operators and Special Characters}
\subsection*{Arithmetic Operators}
MATLAB uses standard mathematical symbols: \lstinline!+!, \lstinline!-!, \lstinline!*!, \lstinline!/!, \lstinline!^!.

\noindent For element-wise operations, prepend the mathematical operator with a dot (\lstinline!.!).
\begin{multicols}{2}
    \subsection*{Relational Operators}
    \begin{table}[H]
        \centering
        \begin{tabular}{c | c}
            \toprule
            \textbf{Symbol} & \textbf{Role}            \\
            \midrule
            \lstinline!==!  & Equal to                 \\
            \lstinline!~=!  & Not equal to             \\
            \lstinline!>!   & Greater than             \\
            \lstinline!>=!  & Greater than or equal to \\
            \lstinline!<!   & Less than                \\
            \lstinline!<=!  & Less than or equal to    \\
            \bottomrule
        \end{tabular}
    \end{table}
    \columnbreak
    \subsection*{Logical Operators}
    \begin{table}[H]
        \centering
        \begin{tabular}{c | c}
            \toprule
            \textbf{Symbol} & \textbf{Role}           \\
            \midrule
            \lstinline!&!   & logical \lstinline!AND! \\
            \lstinline!|!   & logical \lstinline!OR!  \\
            \lstinline!~!   & logical \lstinline!NOT! \\
            \bottomrule
        \end{tabular}
    \end{table}
\end{multicols}
\subsection*{Special Characters}
\begin{table}[H]
    \centering
    \begin{tabular}{c | c}
        \toprule
        \textbf{Symbol} & \textbf{Role}                                                      \\
        \midrule
        \lstinline!,!   & Separator for row elements                                         \\
        \lstinline!:!   & Index all subscripts in array dimension; create unit-spaced vector \\
        \lstinline!;!   & Separator for column elements; suppress output                     \\
        \lstinline!( )! & Operator precedence                                                \\
        \lstinline![ ]! & Array creation, multiple output argument assignment                \\
        \lstinline!%!   & Comment                                                            \\
        \lstinline!""!  & String constructor                                                 \\
        \lstinline!~!   & Argument placeholder (suppress specific output)                    \\
        \lstinline!=!   & Assignment                                                         \\
        \bottomrule
    \end{tabular}
\end{table}
\section*{Special Arrays}
\begin{lstlisting}
zeros(M, N) % zero array
false(M, N) % logical false array
\end{lstlisting}
\section*{Array Comparisons}
\begin{lstlisting}
A = rand(M, N); % random array
mask = A > 0.5; % logical array, true (1) if: >0.5 and false (0) if: <=0.5
\end{lstlisting}
\section*{Other Functions}
\begin{lstlisting}
who                     % list workspace variables  
who -file <mat file>    % list variables in .mat file 
pause(x)                % pause procedure for x seconds 
\end{lstlisting}
\section*{Image Processing}
\subsection*{Finding Area}
\begin{lstlisting}
f = figure;                                          % create a figure object
imshow('file.png');                                  % display image 
p = drawpolygon(f.Children)                          % trace polygon on image
cP = p.Position;                                     % n by 2 array of (x, y) coordinates
areaPxSquared = polyarea(cP(:, 1), cP(:, 2));        % area [px^2]
l = drawline(f.Children)                             % trace scale bar on image
cL = l.Position;                                     % 2 by 2 array of (x, y) coordinates
scalePx = sqrt((cL(2, 1) - cL(1, 1))^2 + ...
               (cL(2, 2) - cL(1, 2))^2);             % scale length [px]
mPerPx = actualScaleLength / scalePx;                % [m] per [px]
mSquaredPerPxSquared = mPerPx^2;                     % [m^2] per [px^2]
areaMSquared = mSquaredPerPxSquared * areaPxSquared; % area [m^2]
\end{lstlisting}
\subsection*{Geolocation}
\begin{lstlisting}
longitudes = [...];                                         % e.g. 153.02
latitudes = [...];                                          % e.g. -27.46
origin = [mean(longitudes), mean(latitudes)];               % arbitrary origin
radius = 6373.6;                                            % radius of Earth
circumference = 2 * pi * radius;                            % circumference of Earth
kmPerDegLatitude = circumference / 360;                     
kmPerDegLongitude = kmPerDegLatitude * cos(deg2rad(-27.5)); % near Brisbane
x = (longitudes - origin(1)) * kmPerDegLongitude;           % x coordinates
y = (latitudes - origin(2)) * kmPerDegLatitude;             % y coordinates
plot(x, y, '.');                                            % plot locations
\end{lstlisting}
\section*{Images from Arrays}
\begin{lstlisting}
imshow(A)   % Display image
image(A)    % Display image, recommended if combining with other plots
\end{lstlisting}
\subsection*{Random Images}
\begin{lstlisting}
randi([0, 255], M, N, 'uint8');     % greyscale image
randi([0, 255], M, N, 3, 'uint8');  % colour image
\end{lstlisting}
\subsection*{Creating Colour Images by Modifying Array Entries}
\begin{lstlisting}
A = 255 * zeros(M, N, 3, 'uint8');  % black image
A = 255 * ones(M, N, 3, 'uint8');   % white image
% Access individual channels
rMask = A(:, :, 1);                 % red channel
gMask = A(:, :, 2);                 % green channel
bMask = A(:, :, 3);                 % blue channel
% Access specific region and change its colour to rgb(r, g, b)
A(x1:x2, y1:y2, 1) = r;             % modify red value of (x1:x2, y1:y2)
A(x1:x2, y1:y2, 2) = g;             % modify green value of (x1:x2, y1:y2)
A(x1:x2, y1:y2, 3) = b;             % modify blue value of (x1:x2, y1:y2)
\end{lstlisting}
\subsection*{Editing an Image from a File}
\begin{lstlisting}
theImage = imread('image.png');     % access image 
% Mask a colour range to be modified
mask = theImage(:, :, 1) > r & theImage(:, :, 2) > g & theImage(:, :, 3) > b;
% Modify channels of selected colour range - accessing individual channels shown in previous section
rMask(mask) = rNew;                 % modify red value in masked image
gMask(mask) = gNew;                 % modify green value in masked image
bMask(mask) = bNew;                 % modify blue value in masked image
theNewImage(:, :, 1) = rMask;       % assign red mask to new array 
theNewImage(:, :, 2) = gMask;       % assign green mask to new array
theNewImage(:, :, 3) = bMask;       % assign blue mask to new array
\end{lstlisting}
\subsection*{Create and Save an Animation}
\begin{lstlisting}
f = figure;
set(f, 'Visible', 'on');
video = VideoWriter('video.avi');   % create video object
open(video);                        % open video for write access
x = [...];                          % x values
y = [...];                          % y values
p = plot(x(1), y(1));               % create plot object
for i = 1:length(x)                 % iterate through each frame
    % Update plot object data
    p.XData = x(i);
    p.YData = y(i);
    hold on;                        % use if previous points should remain on figure
    drawnow;                        % update figure
    frame = getFrame;               % get snapshot of current axes
    writeVideo(video, frame)        % write frame to video
end
hold off                            % use if hold on was used
close(video);                       % close the file
\end{lstlisting}
\section*{Sound Processing}
\subsection*{Create pure tone}
\begin{lstlisting}
f = 523.251;                        % frequency of note
Fs = 8192;                          % sampling rate
l = 1;                              % length of tone [s]
t = 0: 1 / Fs : l;                  % vector of evenly-spaced times to sample at
y = sin(2 * pi * f * t);            % sine wave sampled at t
\end{lstlisting}
\subsection*{Processing sounds}
\begin{lstlisting}
[y1 + y2]                           % combine y1 and y2 (must be the same dimension)
[y1; y2]                            % append y2 after y1
soundsc(y, Fs)                      % play sound 
resample(y, Fs, Q)                  % resample sound at the new sampling rate: Fs / Q
Fs / 2                              % half speed
Fs * 2                              % double speed
audiowrite('audio.wav', y, Fs)      % write sound to audio.wav
\end{lstlisting}
Let $y$ be a column vector
\begin{lstlisting}
duration = length(y) / Fs;                  % duration of sound [s]
% equivalent methods for defining a time vector
t = 0 : 1 / Fs : duration;                  % using the colon operator
t = linspace(0, duration, length(y) + 1);   % using the linspace function
\end{lstlisting}
\section*{Random Walks}
\subsection*{Initialisation}
\begin{lstlisting}
M = 50;                                             % number of particles
N = 200;                                            % number of steps
delta = 1;                                          % size of step
p = 0.5;                                            % probability of jumping left
A = zeros(N + 1, M);                                % initialise particles at zero
for i = 1:N                                         % iterate through each step
    r = rand(1, M);                                 % random probability for each particle
    leftMask = r < p;                               % mask left-moving particles
    A(i + 1, leftMask) = A(i, leftMask) - delta;    % move leftMask left    
    A(i + 1, ~leftMask) = A(i, ~leftMask) + delta;  % move ~leftMask right
end
\end{lstlisting}
Animated Step vs Position Plot
\begin{lstlisting}
p = plot(A(1:2, :), '.-');                  % create plot object
L = max(abs(A(:)));                         % maximum distance reached
axis([0 N -L L]);                           % set axis bounds
for i = 1:N                                 % iterate through each step
    for j = 1:M                             % iterate through each particle
        p(j).YData = A(1:i, j);             % update plot object data
        hold on                             % hold until all particles trees have been plotted 
    end
    hold off                                % hold off for next iteration
    drawnow                                 % update figure
end
\end{lstlisting}
1D Animated Position Plot
\begin{lstlisting}
p = plot(A(1, :), zeros(1, M), '.');        % create plot object
L = max(abs(A(:)));                         % maximum distance reached
axis([-L L -1 1]);                          % set axis bounds
for i = 1:N                                 % iterate through each step
    p.XData = A(i, :);                      % update plot object data
    drawnow                                 % update figure
end
\end{lstlisting}
\section*{Cellular Automata}
\begin{lstlisting}
C = 100;                                        % number of cells
N = 50;                                         % number of steps
A = false(N + 1, C);                            % initialise all positions to be empty
A(1, :) = rand(1, C) > 0.5;                     % use random initial state
% Manually define initial state using an explicit assignment
A(1, :) = [...];                                % length of row vector must be C
for i = 1:N                                     % iterate through each step
    P = A(i, :)                                 % centre cells
    % Wrap-around ghost boundary cell 
    L = [P(C), P(1:C - 1)];
    R = [P(2:C), P(1)];
    % Dead boundary cell
    L = [0, P(1:C - 1)];
    R = [P(2:C), 0];
    % List of all 1D configurations
    C000 = (L == 0 & P == 0 & R == 0);
    C001 = (L == 0 & P == 0 & R == 1);
    C010 = (L == 0 & P == 1 & R == 0);
    C011 = (L == 0 & P == 1 & R == 1);
    C100 = (L == 1 & P == 0 & R == 0);
    C101 = (L == 1 & P == 0 & R == 1);
    C110 = (L == 1 & P == 1 & R == 0);
    C111 = (L == 1 & P == 1 & R == 1);
    liveMask = C000 | ... | ...;                % cellular automation rule(s)
    A(i + 1, liveMask) = 1;                     % set live cells for next generation
end
imshow(~A, 'InitialMagnification', 'Fit');      % Display black live cells
\end{lstlisting}
\end{document}